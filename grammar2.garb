#{
grammar.rules[:sentence].children << Rule::many_one(Rule::whitespace).map { "\n".to_repr }
#}
#{
grammar.rules[:eof] = Rule::not(Rule::any)
grammar.rules[:comment] = "#".to_rule >> Rule::many(Rule::not("\n") >> Rule::any) >> ("\n".to_rule | :eof)
grammar.rules[:sentence].children << Rule::call(:comment)
#}
# Garbanzo predefined grammar set v.2
# 2016/02/29 akamah
#

# 最初に，バージョン1に対する構文定義が続く．
#
# 数値を定義 (1428)
#{
grammar.rules[:number] = Rule::many_one(Rule::one_of("0123456789")).map {|as|
  as.map(&:value).join.to_i.to_repr
}.token

# 識別子を定義 (hoge, poyo)
grammar.rules[:identifier] = Rule::many_one(Rule::one_of("@abcdefghijklmnopqrstuvwxyz.")).map {|as|
  as.map(&:value).join.to_repr
}.token
#}

# 文字列を定義 ("string")
#{
grammar.rules[:string] = ["\"", Rule::many(!"\"".to_rule >> Rule::any), Rule::token("\"")].sequence {|_, cs, _|
  cs.map(&:value).join.to_repr
}.token
#}

# print文 (print 3)
#{
grammar.rules[:sentence].children << ["print", Rule::many_one(Rule::whitespace), :expression].sequence { |_, _, n|
  Repr::print(n)
}
#}

# pathとは、a/b/cのように、オブジェクトのキーを指定するもの。
#{
grammar.rules[:path] = [:identifier, Rule::many(Rule::string("/") >> :identifier)].sequence { |a, idents|
  [a] + idents
}
#}

# $path という記法で、親を辿れるようにする
#{
grammar.rules[:path] = grammar.rules[:path] | ["$", :path].sequence { |_, idents|
  ["..".to_repr] + idents
}
#}

# 変数はパスで表される
#{
grammar.rules[:variable]  = :path.to_rule.map {|idents|
  idents.reduce(Repr::getenv) { |body, key|
    Repr::get(body, key)
  }
} | ["/", :path].sequence {|_, idents|
  idents.reduce(Repr::get(Repr::getenv, '/'.to_repr)) { |body, key|
    Repr::get(body, key)
  }
}
#}


# 原始式は、数値か文字列か変数のいずれかである
#{
grammar.rules[:primitive] = [:number, :string, :variable].choice
#}

# おっと忘れてた、ストアオブジェクトも原始式
#{
grammar.rules[:pair] = [:identifier, Rule::token(":"), :expression].sequence { |id, _, expr|
  [id, expr]
}

grammar.rules[:primitive].children <<
  [Rule::token("["), Rule::separate_by(:pair, Rule::token(",")), Rule::token("]")].sequence { |_, lst, _|
    Repr::store(lst.to_h)
  }
#}

# 関数呼び出しは、原始式にカッコを後置したもの, func(expr)
#{
grammar.rules[:call] = [:primitive, Rule::token("("), :expression, Rule::token(")")].sequence {|func, _, arg, _|
    Repr::call(func, arg)
} | :primitive
#}


# termは、関数呼び出しとパスでのアクセスを加えたもの
#{
grammar.rules[:term] = 
  [:call, Rule::optional(Rule::string("/") >> :path, [])].sequence { |a, idents|
  idents.reduce(a) { |body, key|
    Repr::get(body, key)
  }
}
#}

# かけ算は、termをくっつけたもの
#{
grammar.rules[:multiplication] = 
  [:term, Rule::many(Rule::string('*').token >> :term)].sequence { |num, mults|
  mults.reduce(num) { |expr, adder|
    Repr::mult(expr, adder)
  }
}
#}

# 足し算は、multiplication二つをプラスでくっつけたもの。
#{
grammar.rules[:addition] = 
  [:multiplication, Rule::many(Rule::string('+').token >> :multiplication)].sequence { |num, adds|
  adds.reduce(num) { |expr, adder|
    Repr::add(expr, adder)
  }
}
#}

# 関数は、いまのところ^{ <sentence> }と書く
#{
grammar.rules[:function] =
  [Rule::token("^{"), Rule::many(:sentence), Rule::token("}")].sequence {|_, body, _|
    a = Repr::lambda(Repr::getenv, Repr::begin(Lib::make_list(*body)))
    a    
  }
#}

#{
grammar.rules[:expression] = [:addition, :function].choice
#}

#{
grammar.rules[:condition] = :expression.to_rule
#}



# 代入構文
#{
grammar.rules[:sentence].children <<
  [:expression, Rule::token("="), :expression].sequence {|object, _, expr|
  Repr::set(object['object'], object['key'], expr)
}
#}

# 繰り返しのwhileループ
#{
grammar.rules[:sentence].children << [Rule::token("while"), :condition, :sentence].sequence {|_, cond, body|
  Repr::while(cond, body)
}
#}

# if文
#{
grammar.rules[:sentence].children << [Rule::token('if'), :expression,
				     :sentence,
				     Rule::token('else'),
				     :sentence].sequence { |_, cond, csq, _, alt|
  Repr::if(cond, csq, alt)				     
}
#}

# スコープの導入。これは、空の引数を取る関数を呼び出すこととする。
#{
grammar.rules[:sentence].children << [Rule::token("{"), Rule::many(:sentence), Rule::token("}")].sequence { |_, lst, _|
  Repr::scope(Lib::make_list(*lst))
}
#}
#  Repr::call(Repr::lambda(Repr::getenv, body), Repr::Store.new({}))


# 式の末尾にセミコロンをつけると文になるやつ
#{
grammar.rules[:sentence].children << [:expression, Rule::token(";")].sequence {|e, _| e}
#}  

#{
grammar.rules[:expression].children << ["'".to_rule, :sentence].sequence {|_, s|
  Repr::quote(s)
}
#}

#{
grammar.rules[:expression].children << ["%".to_rule, :expression].sequence {|_, s|
  Repr::eval(Repr::getenv, s)
}
#}





# 改行 ################################################
newline = '/parser/sentence/children/newline = '{
  [@: "terminal", string:"
"];
}

setnewline = '/parser/newline = /parser/sentence/children/newline

print newline
print setnewline

# 一行コメント
comment = '/parser/comment = '{
  [@: "terminal", string: "#"];
  [@: "many", parser: [@: "quote", value: [@: "noneof", string: "
"]]];
  "";
}

setcomment = '/parser/sentence/children/comment = /parser/comment

print comment
print setcomment

# シンボル ################################################
symbol = 'parser/symbol = '{
    oo = [@: "quote", value: [@: "oneof", string: ".@abcdefghijklmnopqrstuvwxyz"]]
    %/parser/whitespaces;
    result  = %oo
    cs = [@: "many", parser: oo]
    %/parser/whitespaces;

    /foreach([store: cs, func: ^{
      ../result = [@: "append", left: ../result, right: value]
    }]);

    result;
}

setsymbol = '/parser/expression/children/symbol = /parser/symbol
print symbol
# print setsymbol


# 整数 ################################################
integer = '/parser/integer = '{
    digit = [@: "quote", value: [@: "oneof", string: "0123456789"]]
    a = [@: "sub", left: [@: "tocode", string: %digit], right: [@: "tocode", string: "0"]]
    rest = [@: "many", parser: digit]
    ten = [@: "sub", left: [@: "tocode", string: "K"], right: [@: "tocode", string: "A"]]
    
    "generate";
    /foreach([store: rest, func: ^{
      n = [@: "sub", left: [@: "tocode", string: value], right: [@: "tocode", string: "0"]]
      ../a = ../a * ../ten + n
    }]);

    a;
}

setinteger = '/parser/expression/children/integer = /parser/integer

print integer
print setinteger

# 真偽値 ################################################
true = '/parser/true = '{
    [@: "terminal", string: "true"];
    [@: "equal", left: "", right: ""];
}

settrue = '/parser/expression/children/true = /parser/true

false = '/parser/false = '{
    [@: "terminal", string: "false"];
    [@: "equal", left: "", right: "a"];
}

setfalse = '/parser/expression/children/false = /parser/false

print true
#print settrue
print false
#print setfalse

# ユーティリティ #########################################
## 複数の文
somesentences = '/parser/somesentences = '{
    sts = [@: "many", parser: '{
      %/parser/whitespaces;
      %/parser/sentence;
    }]
    %/parser/whitespaces;

    sts;
}

print somesentences


# ブロック (begin) #######################################
block = '/parser/block = '{
    [@: "terminal", string: "begin"];
    sentences = %/parser/somesentences
    [@: "terminal", string: "end"];	
    result = [@: "datastore", object: [@: "begin", body: sentences]]

    result;
}

setblock = '/parser/sentence/children/block = /parser/block

print block
# print setblock

# 関数 ##############################################
function = '/parser/function = '{
    [@: "terminal", string: "fun"];
    %/parser/whitespaces;
    [@: "terminal", string: "("];
    %/parser/whitespaces;
    
    args = /sepby([parser: /parser/symbol, sep: '{
      %/parser/whitespaces;
      [@: "terminal", string: ","];
      %/parser/whitespaces;
    }])
    [@: "terminal", string: ")"];
    
    sts = %/parser/somesentences
    [@: "terminal", string: "end"];

    setargs = []

    "loop";
    /foreach([store: args, func: ^{
      [@: "set", object: ../setargs, key: key, value:
        [@: "datastore", object:
	  [@: "set", object: '[@: "getenv"];, key: value, value:
	    [@: "datastore", object:
	      [@: "get", object: [@: "quote", value: [@: "getenv"]], key: key]]]]];
    }]);

    body = [@: "datastore", object:
              [@: "begin", body:
	        [setargs: [@: "datastore", object: [@: "begin", body: setargs]],
		 thebody: [@: "datastore", object: [@: "begin", body: sts]]]]]

    x = [@: "datastore", object: [@: "lambda", env: [@: "quote", value: [@: "getenv"]], body: body]]
    x;
}

setfunction = '/parser/expression/children/function = /parser/function
print function
# print setfunction

# 命令 ################################################
#command = 'parser/command = '{
#  [@: "terminal", string: "@"];
#  comname = %/parser/symbol
#  args = %/parser/datastore
#  args/@ = comname
#  args;
#}
#
#setcommand = '/parser/sentence/children/command = /parser/command
#
#print command
#print setcommand

# パス ################################################
path = 'parser/path = '{
    p = %/parser/symbol

    ps = [@: "many", parser: '{
        [@: "terminal", string: "/"];
        %/parser/symbol;
    }]

    result = []
    result/head = p

    "hoge";

    /foreach([store: ps, func: ^{
      [@: "set", object: ../result, key: key, value: value];
    }]);


    result;
}

print path

# 変数 ################################################
variable = '/parser/variable = '{
    [@: "terminal", string: ""];
    name = %/parser/path
    result = [@: "datastore", object: [@: "getenv"]]
    "hoge";
   
    /foreach([store: name, func: ^{
#        print "-----"
        ../result = [@: "datastore", object: [@: "get", object: ../result, key: value]]
    }]);

    result;
}

setvariable = '/parser/expression/children/variable = /parser/variable

print variable
# print setvariable

rootvar = 'parser/rootvar = '{
    name = %/parser/path
    result = [@: "copy", object: '[@: "get", object: [@: "getenv"], key: "/"];]
    "hoge";
   
    /foreach([store: name, func: ^{
#        print "-----"
        ../result = [@: "datastore", object: [@: "get", object: ../result, key: value]]
    }]);

    result;
}

print rootvar

# 代入 ###############################################
assign = '/parser/assign = '{
    ws = /parser/whitespaces
    path = %/parser/variable
    %ws;
    [@: "terminal", string: "="];
    %ws;
    rhe = %/parser/expression

    path/@ = "set"
    path/value = rhe

    path;
}

setassign = '/parser/sentence/children/assign = /parser/assign

print assign
print setassign

# ブロック ################################################
do = '/parser/do = '{
    [@: "terminal", string: "block"];
    quoted = %/parser/somesentences
    [@: "terminal", string: "end"];

    result = [@: "datastore", object: [@: "quote"]]
    result/value = [@: "datastore", object: [@: "scope", body: quoted]]

    result;
}

setdo = '[@: "insertprev", object: /parser/expression/children,
          origin: [@: "firstkey", object: /parser/expression/children],
	  key: "do", value: /parser/do];

print do
# print setdo

loop = '/parser/while = '{
    [@: "terminal", string: "while"];
    %/parser/whitespaces;
    cond = %/parser/expression
    sts = %/parser/somesentences
    [@: "terminal", string: "end"];
    body = [@: "datastore", object: [@: "begin", body: sts]]

    result = [@: "datastore", object: [@: "while", condition: cond, body: body]]

    result;
}

setloop = '[@: "insertprev", object: /parser/sentence/children,
            origin: [@: "firstkey", object: /parser/sentence/children],
	    key: "while", value: /parser/while];

print loop
print setloop


branch = '/parser/if = '{
    [@: "terminal", string: "if"];
    %/parser/whitespaces;
    cond = %/parser/expression

    csq = %/parser/somesentences

    [@: "terminal", string: "else"];

    alt = %/parser/somesentences
    [@: "terminal", string: "end"];

    c = [@: "datastore", object: [@: "begin", body: csq]]
    a = [@: "datastore", object: [@: "begin", body: alt]]
    
    result = [@: "datastore", object: [@: "if", condition: cond, consequence: c, alternative: a]]
    result;
}

setbranch = '[@: "insertprev", object: /parser/sentence/children,
            origin: [@: "firstkey", object: /parser/sentence/children],
	    key: "if", value: /parser/if];

print branch
print setbranch

# sepby: あるパーサに区切られたパーサを複数読み込む．
# parser = "hoge", sep = ","なら，
# "" (空白)
# "hoge"
# "hoge,hoge"
# ...
# にマッチする．
# Haskellのパーサコンビネータにインスパイアされた

sepbyone = '/sepbyone = ^{
  head = %parser
  tail = [@: "many", parser: '{
    %../sep;
    %../parser;
  }]

  result = []
  [@: "set", object: result, key: 0, value: head];

  i = 1
  "loop";
  /foreach([store: tail, func: ^{
    [@: "set", object: ../result, key: ../i, value: value];
    ../i = [@: "add", left: ../i, right: 1]
  }]);

  result;
}

sepby = '/sepby = ^{
  [@: "choice", children:
    [more: /sepbyone([parser: parser, sep: sep]),
     zero: []]];
}

print sepbyone
print sepby

### 呼び出し #####################
call = '/parser/call = '{
  [@: "terminal", string: "!"];
  f = %/parser/expression

  [@: "terminal", string: "("];
  args = /sepby([parser: /parser/expression, sep: '{
    %/parser/whitespaces;
    [@: "terminal", string: ","];
    %/parser/whitespaces;
  }])

  [@: "terminal", string: ")"];

  [@: "datastore", object: [@: "call", func: f, args: args]];
}

setcall = '/parser/expression/children/call = /parser/call
  
print call
#print setcall


### 優先順位付きexpression  ###############
exprtab = '/parser/exprtab = [@: "datastore", object: []]
print exprtab


numrule = '/parser/exprtab/numrule =
  [prec: 0,
   parser: /parser/integer]

print numrule

# まずは，未実装である足し算と掛け算を実装してみる．
# 足し算の優先順位は100
plusrule = '/parser/exprtab/addrule =
  [prec: 100,
   parser: '{
     left  = [@: "precrule", table: /parser/exprtab, prec: 99]
     [@: "terminal", string: "+"];
     right = [@: "precrule", table: /parser/exprtab, prec: 100]
     [@: "datastore", object: [@: "add", left: left, right: right]];
   }]

print plusrule

minusrule = '/parser/exprtab/minusrule =
  [prec: 100,
   parser: '{
     left  = [@: "precrule", table: /parser/exprtab, prec: 99]
     [@: "terminal", string: "-"];
     right = [@: "precrule", table: /parser/exprtab, prec: 100]
     [@: "datastore", object: [@: "sub", left: left, right: right]];
   }]

print minusrule

# 掛け算の優先順位は90
multrule = '/parser/exprtab/multrule =
  [prec: 90,
   parser: '{
     left  = [@: "precrule", table: /parser/exprtab, prec: 89]
     [@: "terminal", string: "*"];
     right = [@: "precrule", table: /parser/exprtab, prec: 90]
     [@: "datastore", object: [@: "mult", left: left, right: right]];
   }]

print multrule

callrule = '/parser/exprtab/callrule =
  [prec: 30,
   parser: '{
     f = [@: "precrule", table: /parser/exprtab, prec: 29]
     [@: "terminal", string: "("];
     args = /sepby([parser: /parser/expression, sep: '{
       %/parser/whitespaces;
       [@: "terminal", string: ","];
       %/parser/whitespaces;
     }])

     [@: "terminal", string: ")"];
     [@: "datastore", object: [@: "call", func: f, args: args]];
   }]

print callrule

truerule = '/parser/exprtab/truerule =
  [prec: 20,
   parser: /parser/true]
   
falserule = '/parser/exprtab/falserule =
  [prec: 20,
   parser: /parser/false]
   
print truerule
print falserule

varrule = '/parser/exprtab/varrule =
  [prec: 10,
   parser: /parser/variable]

print varrule


blockrule = '/parser/exprtab/blockrule =
  [prec: 20,
   parser: /parser/do]

print blockrule


funrule = '/parser/exprtab/funrule =
  [prec: 20,
   parser: /parser/function]

print funrule

lessthanrule = '/parser/exprtab/lessthanrule =
  [prec: 150,
   parser: '{
     left  = [@: "precrule", table: /parser/exprtab, prec: 149]
     [@: "terminal", string: "<"];
     right = [@: "precrule", table: /parser/exprtab, prec: 149]
     [@: "datastore", object: [@: "lessthan", left: left, right: right]];
   }]
  
print lessthanrule

evalrule = '/parser/exprtab/evalrule =
  [prec: 40,
   parser: '{
     [@: "terminal", string: "%"];
     expr = [@: "precrule", table: /parser/exprtab, prec: 40]
     
     [@: "datastore", object: [@: "eval", env: [@: "quote", value: [@: "getenv"]], program: expr]];
  }]
  
print evalrule

stringrule = '/parser/exprtab/stringrule =
  [prec: 0,
   parser: /parser/string]

print stringrule

datastorerule = '/parser/exprtab/datastorerule =
  [prec: 0,
   parser: /parser/datastore]

print datastorerule






newexpr = '/parser/newexpr = '{
  [@: "withcache", table: /parser/exprtab];
}
print newexpr

setnewexpr = '[@: "insertprev", object: /parser/expression/children,
          origin: [@: "firstkey", object: /parser/expression/children],
	  key: "newexpr", value: /parser/newexpr];
print setnewexpr

deleteint = '[@: "remove", object: /parser/expression/children, key: "integer"];
deleteds = '[@: "remove", object: /parser/expression/children, key: "datastore"];
deletestr = '[@: "remove", object: /parser/expression/children, key: "string"];

print deleteint
print deleteds
print deletestr


# ここで，<式> ; という記法を文とみなすこととする．
exprsentence = '/parser/exprsentence = '{
  e = %/parser/expression
  [@: "terminal", string: ";"];
  e;
}

setexprsentence = '/parser/sentence/children/exprsentence = /parser/exprsentence

print exprsentence
print setexprsentence

### QUASIQUOTE ##################




#qqfunc = '/quasiquote = ^{
#  if [@: "isdatastore", value: object] {
#    object = ../object
#
#    if [@: "and", left:  [@: "exist", object: object, key: "@"],
#                  right: [@: "equal",
#		    left: [@: "get", object: object, key: "@"], right: "unquote"]] {
#        [@: "get", object: ../object, key: "value"];
#    } else {
#      result = [@: "datastore", object:[]]
#      "hoge";
#      /foreach([store: ../object, func: ^{
#        [@: "set", object: ../result, key: key,
#	  value: /quasiquote([@: "datastore", object: [object: value]])];
#      }]);
#      [@: "datastore", object: [@: "datastore", object: result]];
#    }
#  } else {
#    [@: "datastore", object: [@: "quote", value: ../object]];
#  }
#}
#
#quasiquote = '/parser/quasiquote = '{
#  [@: "terminal", string: "`"];
#  st = %/parser/sentence
#  [@: "terminal", string: "`"];  
#  %/parser/whitespaces;
#  /quasiquote([object: st]);
#}
#
#setquasiquote = '/parser/sentence/children/quasiquote = /parser/quasiquote
#
#print qqfunc
#print quasiquote
#print setquasiquote
#
#
# 代入できます
# i = 0
# a = 0
# b = 1
# 
# print "fibonacci numbers"
# 
# フィボナッチ数を出力する
# while i != 10 {
#  $i=$i+1
#   tmp=$b
#   $b=$a+$b
#   $a=tmp
#   print $a
# }
# 
# print "----------"
# 
# 
# if 1==2 {
#   print "true"
# } else {
#   print "false"
# }
# 
# store=[]
# store/a=0
# store/b=20
# store/c=[]
# store/d="hogehoge"
# store/c/hoge=[]
# print store
# 
# args = [left: 42, right: 32]
# 
# print /add
# print "42 + 32 = "
# print /add(args)
# 
# f=^{
#   if a==10 {
#     print 100
#   } else {
#     print $a
#     e = []
#     e/a = $a+1
#     $$f(e);
#   }
# }
#     
# print f(store)