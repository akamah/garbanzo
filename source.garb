#{
grammar.rules[:sentence].children << Rule::whitespaces
#}
#{
grammar.rules[:comment] = "#".to_rule >> Rule::many(Rule::not("\n".to_rule) >> Rule::any) >> "\n".to_rule
grammar.rules[:sentence].children << Rule::call(:comment)
#}
# コメントを実装したぞ！

# 数値を定義
#{
grammar.rules[:number] = Rule::many_one(Rule::one_of("0123456789")).map {|as|
  as.map(&:value).join.to_i.to_repr
}
# 識別子を定義する
grammar.rules[:identifier] = Rule::many_one(Rule::one_of("abcdefghijklmnopqrstuvwxyz.")).map {|as|
  as.map(&:value).join.to_repr
}
#}

# print文
#{
grammar.rules[:sentence].children << ["print", " ", :expression].sequence { |_, _, n|
  Repr::print(n)
}
#}

# pathとは、a/b/cのように、オブジェクトのキーを指定するもの。
#{
grammar.rules[:path] = [:identifier, Rule::many(Rule::string("/") >> :identifier)].sequence { |a, idents|
  [a] + idents
} | ["$", :path].sequence { |_, idents|
  ["..".to_repr] + idents
}
#}

# 変数はパスで表される
#{
grammar.rules[:variable]  = [:path].sequence {|idents|
  idents.reduce(Repr::getenv) { |body, key|
    Repr::get(body, key)
  }
}
#}

# 原始式は、数値かパスのいずれかである
#{
grammar.rules[:primitive] = [:number, :variable].choice
#}

# おっと忘れてた、空のストアオブジェクトも原始式
#{
grammar.rules[:primitive].children <<
  "[]".to_rule.map { Repr::Store.new({}) }
#}

# 関数呼び出しは、原始式にカッコを加えたもの。
#{
grammar.rules[:call] = [:primitive, "(", :expression, ")"].sequence {|func, _, arg, _|
  Repr::call(func, arg)
} | :primitive
#}


# termは、関数呼び出しとパスでのアクセスを加えたもの
#{
grammar.rules[:term] = 
  [:call, Rule::optional(Rule::string("/") >> :path, [])].sequence { |a, idents|
  idents.reduce(a) { |body, key|
    Repr::get(body, key)
  }
}
#}

# 足し算は、term二つをプラスでくっつけたもの。
#{
grammar.rules[:addition] = 
  [:term, Rule::many(Rule::string('+') >> :term)].sequence { |num, adds|
  adds.reduce(num) { |expr, adder|
    Repr::add(expr, adder)
  }
}
#}

#{
grammar.rules[:function] =
  ["^{", :sentence, "}"].sequence {|_, body, _|
    Repr::function(nil, body)
  }
#}

#{
grammar.rules[:expression] = [:addition, :function].choice
#}

#{
grammar.rules[:condition] = [[:expression, "==", :expression].sequence {|l, _, r|
                               Repr::equal(l, r)
                             }, [:expression, "!=", :expression].sequence {|l, _, r|
                               Repr::notequal(l, r)
                             }].choice
#}

#{
grammar.rules[:sentence].children <<
  [:expression, "=", :expression].sequence {|object, _, expr|
  Repr::set(object['object'], object['key'], expr)
}
#}

#{
grammar.rules[:sentence].children << ["while", Rule::whitespaces, :condition, Rule::whitespaces, :sentence].sequence {|_, _, cond, _, body|
  Repr::while(cond, body)
}
#}

#{
grammar.rules[:sentence].children << ["{", Rule::many(Call.new(:sentence)), "}"].sequence { |_, lst, _|
  newstore = Repr::set(Repr::getenv, "nextEnv".to_repr, Repr::Store.new({}))				  
  newenv = Repr::set(Repr::get(Repr::getenv, "nextEnv".to_repr), "..".to_repr, Repr::getenv)
  enter  = Repr::setenv(Repr::get(Repr::getenv, "nextEnv".to_repr))
  leave  = Repr::setenv(Repr::get(Repr::getenv, "..".to_repr))
  Repr::begin(Lib::make_list(newstore, newenv, enter, *lst, leave))
}
#}

#{
grammar.rules[:sentence].children << [:expression, ";"].sequence {|e, _| e}
#}  

i=0
a=0
b=1

while i!=10 {
  $i=$i+1
  tmp=$b
  $b=$a+$b
  $a=tmp
  print $a
}

i=0
sum=0
while i!=10 {
  $i=$i+1
  j=0
  while j!=10 {
    $j=$j+1
    $$sum=$$sum+1
  }
}

print sum
store=[]
store/a=10
store/b=20
store/c=[]
store/c/hoge=[]
print store

f=^{a+b+12;}
print f(store)
