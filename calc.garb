#{
grammar.rules[:sentence].children << Rule::many_one(Rule::whitespace).map { false.to_repr }
#}
#{
grammar.rules[:comment] = "#".to_rule >> Rule::many(Rule::not("\n") >> Rule::any) >> "\n"
grammar.rules[:sentence].children << Rule::call(:comment)
#}
# コメントを実装したぞ！

# 数値を定義 (1428)
#{
grammar.rules[:number] = Rule::many_one(Rule::one_of("0123456789")).map {|as|
  as.map(&:value).join.to_i.to_repr
}.token

# 識別子を定義 (hoge, poyo)
grammar.rules[:identifier] = Rule::many_one(Rule::one_of("abcdefghijklmnopqrstuvwxyz.")).map {|as|
  as.map(&:value).join.to_repr
}.token
#}

# 文字列を定義 ("string")
#{
grammar.rules[:string] = ["\"", Rule::many(!"\"".to_rule >> Rule::any), Rule::token("\"")].sequence {|_, cs, _|
  cs.map(&:value).join.to_repr
}.token
#}

# print文 (print 3)
#{
grammar.rules[:sentence].children << ["print", Rule::many_one(Rule::whitespace), :expression].sequence { |_, _, n|
  Repr::print(n)
}
#}

# pathとは、a/b/cのように、オブジェクトのキーを指定するもの。
#{
grammar.rules[:path] = [:identifier, Rule::many(Rule::string("/") >> :identifier)].sequence { |a, idents|
  [a] + idents
}
#}

# $path という記法で、親を辿れるようにする
#{
grammar.rules[:path] = grammar.rules[:path] | ["$", :path].sequence { |_, idents|
  ["..".to_repr] + idents
}
#}

# 変数はパスで表される
#{
grammar.rules[:variable]  = :path.to_rule.map {|idents|
  idents.reduce(Repr::getenv) { |body, key|
    Repr::get(body, key)
  }
} | ["/", :path].sequence {|_, idents|
  idents.reduce(Repr::get(Repr::getenv, '/'.to_repr)) { |body, key|
    Repr::get(body, key)
  }
}
#}


# 原始式は、数値か文字列か変数のいずれかである
#{
grammar.rules[:primitive] = [:number, :string, :variable].choice
#}

# おっと忘れてた、ストアオブジェクトも原始式
#{
grammar.rules[:pair] = [:identifier, Rule::token(":"), :expression].sequence { |id, _, expr|
  [id, expr]
}

grammar.rules[:primitive].children <<
  [Rule::token("["), Rule::separate_by(:pair, Rule::token(",")), Rule::token("]")].sequence { |_, lst, _|
    Repr::store(lst.to_h)
  }
#}

# 関数呼び出しは、原始式にカッコを後置したもの, func(expr)
#{
grammar.rules[:call] = [:primitive, Rule::token("("), :expression, Rule::token(")")].sequence {|func, _, arg, _|
  Repr::call(func, arg)
} | :primitive
#}


# termは、関数呼び出しとパスでのアクセスを加えたもの
#{
grammar.rules[:term] = 
  [:call, Rule::optional(Rule::string("/") >> :path, [])].sequence { |a, idents|
  idents.reduce(a) { |body, key|
    Repr::get(body, key)
  }
}
#}

# かけ算は、termをくっつけたもの
#{
grammar.rules[:multiplication] = 
  [:term, Rule::many(Rule::string('*').token >> :term)].sequence { |num, mults|
  mults.reduce(num) { |expr, adder|
    Repr::mult(expr, adder)
  }
}
#}

# 足し算は、multiplication二つをプラスでくっつけたもの。
#{
grammar.rules[:addition] = 
  [:multiplication, Rule::many(Rule::string('+').token >> :multiplication)].sequence { |num, adds|
  adds.reduce(num) { |expr, adder|
    Repr::add(expr, adder)
  }
}
#}

# 関数は、いまのところ^{ <sentence> }と書く
#{
grammar.rules[:function] =
  [Rule::token("^{"), :sentence, Rule::token("}")].sequence {|_, body, _|
    Repr::lambda(Repr::getenv, body)
  }
#}

#{
grammar.rules[:expression] = [:addition, :function].choice
#}

#{
grammar.rules[:condition] = [[:expression, Rule::token("=="), :expression].sequence {|l, _, r|
                               Repr::equal(l, r)
                             }, [:expression, Rule::token("!="), :expression].sequence {|l, _, r|
                               Repr::notequal(l, r)
                             }].choice
#}

# 代入構文
#{
grammar.rules[:sentence].children <<
  [:expression, Rule::token("="), :expression].sequence {|object, _, expr|
  Repr::set(object['object'], object['key'], expr)
}
#}

# 繰り返しのwhileループ
#{
grammar.rules[:sentence].children << [Rule::token("while"), :condition, :sentence].sequence {|_, cond, body|
  Repr::while(cond, body)
}
#}

# if文
#{
grammar.rules[:sentence].children << [Rule::token('if'), :condition,
				     :sentence,
				     Rule::token('else'),
				     :sentence].sequence { |_, cond, csq, _, alt|
  Repr::if(cond, csq, alt)				     
}
#}

# スコープの導入。これは、空の引数を取る関数を呼び出すこととする。
#{
grammar.rules[:sentence].children << [Rule::token("{"), Rule::many(:sentence), Rule::token("}")].sequence { |_, lst, _|
  body = Repr::begin(Lib::make_list(*lst))
  Repr::call(Repr::lambda(Repr::getenv, body), Repr::Store.new({}))
}
#}

# 式の末尾にセミコロンをつけると文になるやつ
#{
grammar.rules[:sentence].children << [:expression, Rule::token(";")].sequence {|e, _| e}
#}  

# 代入できます
i = 0
a = 0
b = 1

print "fibonacci numbers"

# フィボナッチ数を出力する
while i != 10 {
  $i=$i+1
  tmp=$b
  $b=$a+$b
  $a=tmp
  print $a
}

print "----------"

# 
# if 1==2 {
#   print "true"
# } else {
#   print "false"
# }
# 
# store=[]
# store/a=0
# store/b=20
# store/c=[]
# store/d="hogehoge"
# store/c/hoge=[]
# print store
# 
# args = [left: 42, right: 32]
# 
# print /add
# print "42 + 32 = "
# print /add(args)
# 
# f=^{
#   if a==10 {
#     print 100
#   } else {
#     print $a
#     e = []
#     e/a = $a+1
#     $$f(e);
#   }
# }
#     
# print f(store)
